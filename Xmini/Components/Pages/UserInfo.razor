@page "/userinfo/{id}"
@* Der User wird über die Id in der URL identifiziert *@
@using Xmini.Data
@using Microsoft.AspNetCore.Authorization
@using Microsoft.EntityFrameworkCore
@using Xmini.Components.Pages.Components
@using Xmini.Tools

@inject AuthenticationStateProvider AuthStateProvider
@inject IDbContextFactory<ApplicationDbContext> Factory

@attribute [Authorize]

<PageTitle>User</PageTitle>

@* Anzeigen des Benutzernamens *@
@if (User == null)
{
    @* Wenn noch kein User werden Daten noch geladen oder es gibt den User nicht *@
    <p><em>Loading...</em></p>
}
else
{
    @* Bilder nur anzeigen wenn es auch welche gibt *@
    @if (User.BackgroundPicture != null)
    {
        <div class="user-header">
            <img src="@BackgroundImageSource" alt="Headerbild" class="header-img" />
            <div class="avatar-wrap">
                <img src="@ProfileImageSource" alt="Avatar" class="avatar-img" />
            </div>
        </div>
    }
    <div class="fw-bold mt-6">@User.UserName</div>
    @* Wenn der angezeigte User der aktuelle User ist die Buttons zum hochladen der Bilder anzeigen *@
    @if (_isCurrentUser)
    {
        <div class="mb-2">
            <label class="btn btn-sm btn-outline-primary">
                Hintergrund
                <InputFile OnChange="OnBackgroundFileChangeAsync" accept="image/*" style="display:none"/>
            </label>
            <label class="btn btn-sm btn-outline-primary">
                Profil
                <InputFile OnChange="OnProfileFileChangeAsync" accept="image/*" style="display:none"/>
            </label>
        </div>
    }
;
}
<h3 class="mt-3">Posts</h3>
<hr />
@* Anzeigen der letzten Tweets des Benutzers *@
<TweetListComponent ShowOnlyUserId="@Id" />

@code {
    // Parameter für die UserId
    [Parameter]
    public string? Id { get; set; }
    // Der angezeigte User
    public ApplicationUser? User { get; set; }
    // Ob der angezeigte User der aktuell angemeldete User ist
    private bool _isCurrentUser = false;
    // Maximum erlaubt: 10 MB
    private readonly long _maxFileSize = 10 * 1024 * 1024;
    // Versions-Strings für das Hintergrundbild, damit nach dem Hochladen das neue Bild angezeigt wird
    private string _backgroundImageVersion = DateTime.UtcNow.Ticks.ToString();
    // Versions-Strings für das Profilbild, damit nach dem Hochladen das neue Bild angezeigt wird
    private string _profileImageVersion = DateTime.UtcNow.Ticks.ToString();

    protected override async Task OnInitializedAsync()
    {
        ApplicationDbContext dbContext = await Factory.CreateDbContextAsync();
        User = await dbContext.Users.FirstOrDefaultAsync(u => u.Id == Id);
        if (User == null)
        {
            // User nicht gefunden, evtl. Fehlerbehandlung hier
            return;
        }
        // Prüfen, ob der angezeigte User der aktuell angemeldete User ist
        _isCurrentUser = await CheckIfCurrentUserAsync(User.Id);
        await base.OnInitializedAsync();
    }
    /// Pfade für die Bilder mit Versions-String
    private string BackgroundImageSource => $"/images/background/{User?.Id}?v={_backgroundImageVersion}";
    private string ProfileImageSource => $"/images/profile/{User?.Id}?v={_profileImageVersion}";

    /// <summary>
    /// Prüfen, ob der angezeigte User der aktuell angemeldete User ist.
    /// </summary>
    /// <returns></returns>
    private async Task<bool> CheckIfCurrentUserAsync(string userId)
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity?.IsAuthenticated == true)
        {
            return userId == user.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
        }
        return false;
    }
    /// <summary>
    /// Hintergrundbild hochladen und verarbeiten.
    /// </summary>
    /// <param name="e"></param>
    /// <returns></returns>
    private async Task OnBackgroundFileChangeAsync(InputFileChangeEventArgs e)
    {
        var file = e.File;

        if (User == null) return; // Kein Benutzer geladen

        // Prüfung: Typ
        if (!file.ContentType.StartsWith("image/")) return; // Fehlermeldungen lassen wir mal weg - einfach nicht hochladen

        // Prüfung: Größe
        if (file.Size > _maxFileSize) return; // Fehlermeldungen lassen wir mal weg - einfach nicht hochladen
        try
        {
            // // Browser-seitiges Skalieren: RequestImageFileAsync skaliert auf das angegebene Begrenzungsrechteck.
            var resized = await file.RequestImageFileAsync(file.ContentType, 1024, 768);

            using var ms = new MemoryStream();
            await resized.OpenReadStream(_maxFileSize).CopyToAsync(ms);
            // Bild zuschneiden (unten abschneiden)
            User.BackgroundPicture = ImageProcessing.CropTop(ms.ToArray(), resized.ContentType);

            // Metadaten
            User.BackgroundPictureContentType = resized.ContentType;
            ApplicationDbContext dbContext = await Factory.CreateDbContextAsync();
            // User Objekt an den DbContext anhängen und als geändert markieren
            dbContext.Attach(User);
            dbContext.Entry(User).State = EntityState.Modified;
            await dbContext.SaveChangesAsync();
            // Versions-String aktualisieren, damit das neue Bild angezeigt wird
            _backgroundImageVersion = DateTime.UtcNow.Ticks.ToString();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            // Fehlerbehandlung (z. B. Größe überschritten o.ä.)
            Console.WriteLine(ex);
            User.BackgroundPicture = null;
        }
    }
    /// <summary>
    /// Profilbild hochladen und verarbeiten.
    /// </summary>
    /// <param name="e"></param>
    /// <returns></returns>
    private async Task OnProfileFileChangeAsync(InputFileChangeEventArgs e)
    {
        var file = e.File;

        if (User == null) return; // Kein Benutzer geladen

        // Prüfung: Typ
        if (!file.ContentType.StartsWith("image/")) return; // Fehlermeldungen lassen wir mal weg - einfach nicht hochladen

        // Prüfung: Größe
        if (file.Size > _maxFileSize) return; // Fehlermeldungen lassen wir mal weg - einfach nicht hochladen
        try
        {
            // // Browser-seitiges Skalieren: RequestImageFileAsync skaliert auf das angegebene Begrenzungsrechteck.
            var resized = await file.RequestImageFileAsync(file.ContentType, 135, 768);

            using var ms = new MemoryStream();
            await resized.OpenReadStream(_maxFileSize).CopyToAsync(ms);
            // Bild zuschneiden (unten abschneiden)
            User.ProfilePicture = ImageProcessing.CropTop(ms.ToArray(), resized.ContentType, 135);

            // Metadaten
            User.ProfilePictureContentType = resized.ContentType;
            ApplicationDbContext dbContext = await Factory.CreateDbContextAsync();
            dbContext.Attach(User);
            dbContext.Entry(User).State = EntityState.Modified;
            await dbContext.SaveChangesAsync();
            _profileImageVersion = DateTime.UtcNow.Ticks.ToString();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            // Fehlerbehandlung (z. B. Größe überschritten o.ä.)
            Console.WriteLine(ex);
            User.ProfilePicture = null;
        }
    }
}
